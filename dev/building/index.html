<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building · MCPhyloTree.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MCPhyloTree.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><a class="tocitem" href="../basics/">Basics</a></li><li class="is-active"><a class="tocitem" href>Building</a><ul class="internal"><li><a class="tocitem" href="#Converter"><span>Converter</span></a></li><li><a class="tocitem" href="#Newick-Parsing"><span>Newick Parsing</span></a></li><li><a class="tocitem" href="#Tree-Building"><span>Tree Building</span></a></li><li><a class="tocitem" href="#Tree-Clustering"><span>Tree Clustering</span></a></li><li><a class="tocitem" href="#Tree-Consensus"><span>Tree Consensus</span></a></li><li><a class="tocitem" href="#Tree-Ladderizing"><span>Tree Ladderizing</span></a></li></ul></li><li><a class="tocitem" href="../distance/">Distance</a></li><li><a class="tocitem" href="../moves/">Moves</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Building</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Building</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/MCPhyloTree.jl/blob/master/docs/src/building.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Building"><a class="docs-heading-anchor" href="#Building">Building</a><a id="Building-1"></a><a class="docs-heading-anchor-permalink" href="#Building" title="Permalink"></a></h1><h2 id="Converter"><a class="docs-heading-anchor" href="#Converter">Converter</a><a id="Converter-1"></a><a class="docs-heading-anchor-permalink" href="#Converter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.from_df-Tuple{Matrix{Float64}, Vector{String}}" href="#MCPhyloTree.from_df-Tuple{Matrix{Float64}, Vector{String}}"><code>MCPhyloTree.from_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_df(df::Array{Float64,2}, name_list::Vector{String})::GeneralNode</code></pre><p>This function takes an adjacency matrix and a vector of names and turns it into a tree. No checks are performed.</p><p>Returns the root node of the tree.</p><ul><li><code>df</code> : matrix with edge weights</li><li><code>name_list</code> : a list of names such that they match the column indices of the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Converter.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.newick-Tuple{T} where T&lt;:GeneralNode" href="#MCPhyloTree.newick-Tuple{T} where T&lt;:GeneralNode"><code>MCPhyloTree.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newick(root::T)::String  where T&lt;:GeneralNode</code></pre><p>Creates a newick representation of the tree.</p><p>Returns a properly formatted newick String.</p><ul><li><code>node</code> : root node of tree used to create the newick string.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Converter.jl#L71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.newick-Union{Tuple{T}, Tuple{T, AbstractString}} where T&lt;:GeneralNode" href="#MCPhyloTree.newick-Union{Tuple{T}, Tuple{T, AbstractString}} where T&lt;:GeneralNode"><code>MCPhyloTree.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newick(root::T, newickstring::AbstractString) where T&lt;:GeneralNode</code></pre><p>Do the newick recursion. It is meant as the internal iterator function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Converter.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.to_covariance-Union{Tuple{T}, Tuple{N}, Tuple{N, Vector{T}}} where {N&lt;:GeneralNode, T&lt;:Real}" href="#MCPhyloTree.to_covariance-Union{Tuple{T}, Tuple{N}, Tuple{N, Vector{T}}} where {N&lt;:GeneralNode, T&lt;:Real}"><code>MCPhyloTree.to_covariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N&lt;:GeneralNode,T&lt;: Real}</code></pre><p>Calcualte the variance-covariance matrix from <code>tree</code>. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.</p><p>Returns an Array of Real numbers.</p><ul><li><p><code>tree</code> : Node in tree of interest.</p></li><li><p><code>blv</code> : branchlength vector of tree.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Converter.jl#L144-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.to_df-Tuple{GeneralNode}" href="#MCPhyloTree.to_df-Tuple{GeneralNode}"><code>MCPhyloTree.to_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_df(root::GeneralNode)::Tuple{Array{Float64}, Vector{String}}</code></pre><p>This function returns a matrix representation of the tree structure and a vector with the column names. The entry <code>mat[i,j]</code> is the length of the edge connecting node <code>i</code> with node <code>j</code>. Returns Tuple containing the matrix and a vector of names.</p><ul><li><code>root</code> : root of tree used to create matrix represenation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Converter.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.to_distance_matrix-Tuple{T} where T&lt;:GeneralNode" href="#MCPhyloTree.to_distance_matrix-Tuple{T} where T&lt;:GeneralNode"><code>MCPhyloTree.to_distance_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_distance_matrix(tree::T)::Array{Float64,2} where T &lt;:GeneralNode</code></pre><p>Calculate the distance matrix over the set of leaves.</p><p>Returns an Array of Floats.</p><ul><li><code>tree</code> : root node of tree used to perform caclulcation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Converter.jl#L119-L127">source</a></section></article><h2 id="Newick-Parsing"><a class="docs-heading-anchor" href="#Newick-Parsing">Newick Parsing</a><a id="Newick-Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Newick-Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.ParseNewick-Tuple{String}" href="#MCPhyloTree.ParseNewick-Tuple{String}"><code>MCPhyloTree.ParseNewick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParseNewick(filename::String)::Array{GeneralNode, 1}</code></pre><p>This function takes a filename as a String, and returns an array of trees(represented as Node objects). The file should solely consist of newick tree representations, separated by line. The function checks for proper newick formatting, and will return an error if the file is incorrectly formatted.</p><p>Returns an Array of Nodes; each Node is the root of the tree represented by a newick string in the file.</p><ul><li><code>filename</code> : name of file containing newick strings to parse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/ParseNewick.jl#L127-L138">source</a></section></article><h2 id="Tree-Building"><a class="docs-heading-anchor" href="#Tree-Building">Tree Building</a><a id="Tree-Building-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Building" title="Permalink"></a></h2><h2 id="Tree-Clustering"><a class="docs-heading-anchor" href="#Tree-Clustering">Tree Clustering</a><a id="Tree-Clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Clustering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.neighbor_joining-Tuple{Matrix{Float64}, Vector{String}}" href="#MCPhyloTree.neighbor_joining-Tuple{Matrix{Float64}, Vector{String}}"><code>MCPhyloTree.neighbor_joining</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbor_joining(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><p><code>dm</code> : Matrix used to create Tree.</p></li><li><p><code>leaf_names</code> : Array containing names of leaf nodes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Clustering.jl#L125-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.neighbor_joining-Tuple{Matrix{Float64}}" href="#MCPhyloTree.neighbor_joining-Tuple{Matrix{Float64}}"><code>MCPhyloTree.neighbor_joining</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbor_joining(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><code>dm</code> : Matrix from which to create tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Clustering.jl#L151-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.neighbor_joining_int-Tuple{Matrix{Float64}, Vector{FNode}}" href="#MCPhyloTree.neighbor_joining_int-Tuple{Matrix{Float64}, Vector{FNode}}"><code>MCPhyloTree.neighbor_joining_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbor_joining_int(dm::Array{Float64,2},leaves::Vector{FNode})</code></pre><p>–- INTERNAL –- Internal function that is called by both neighbor_joining methods. Contains the actual neighbor-joining algorithm, i.e. builds a phylogenetic tree from the given distance matrix and array of leaves. Returns a node of that tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Clustering.jl#L172-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.upgma-Tuple{Matrix{Float64}, Vector{String}}" href="#MCPhyloTree.upgma-Tuple{Matrix{Float64}, Vector{String}}"><code>MCPhyloTree.upgma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upgma(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><p><code>dm</code> : Matrix from which to create the tree.</p></li><li><p><code>leaf_names</code> : array of strings containing names of leaf nodes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Clustering.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.upgma-Tuple{Matrix{Float64}}" href="#MCPhyloTree.upgma-Tuple{Matrix{Float64}}"><code>MCPhyloTree.upgma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upgma(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><code>dm</code> : Matrix from which to create the tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Clustering.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.upgma_int-Tuple{Matrix{Float64}, Vector{Tuple{FNode, Float64, Int64}}}" href="#MCPhyloTree.upgma_int-Tuple{Matrix{Float64}, Vector{Tuple{FNode, Float64, Int64}}}"><code>MCPhyloTree.upgma_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upgma_int(dm::Array{Float64,2},leaves::Vector{FNode})</code></pre><p>–- INTERNAL –- Internal function that is called by both UPGMA methods. Contains the actual UPGMA algorithm, i.e. builds a phylogenetic tree from the given distance matrix and array of leaves. Returns a node of that tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Clustering.jl#L48-L56">source</a></section></article><h2 id="Tree-Consensus"><a class="docs-heading-anchor" href="#Tree-Consensus">Tree Consensus</a><a id="Tree-Consensus-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Consensus" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.check_node!-Union{Tuple{T}, Tuple{T, Vector{T}, Dict{String, Int64}, Dict{T, Tuple{T, Dict{Int64, T}}}, Dict{T, Tuple{T, Dict{Int64, T}}}}, Tuple{T, Vector{T}, Dict{String, Int64}, Dict{T, Tuple{T, Dict{Int64, T}}}, Dict{T, Tuple{T, Dict{Int64, T}}}, Union{Nothing, Dict{Int64, Bool}}}} where T&lt;:GeneralNode" href="#MCPhyloTree.check_node!-Union{Tuple{T}, Tuple{T, Vector{T}, Dict{String, Int64}, Dict{T, Tuple{T, Dict{Int64, T}}}, Dict{T, Tuple{T, Dict{Int64, T}}}}, Tuple{T, Vector{T}, Dict{String, Int64}, Dict{T, Tuple{T, Dict{Int64, T}}}, Dict{T, Tuple{T, Dict{Int64, T}}}, Union{Nothing, Dict{Int64, Bool}}}} where T&lt;:GeneralNode"><code>MCPhyloTree.check_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_node!(
    ref_node::T, leaves::Vector{T},
    leaf_ranks_reverse::Dict{String, Int64},
    xleft_dict::Dict{T, Tuple{T, Dict{Int64, T}}},
    xright_dict::Dict{T, Tuple{T, Dict{Int64, T}}},
    marked_nodes::Union{Dict{Int64, Bool, Nothing}}=nothing
    )::Union{Nothing, Tuple{T, T, T, Dict{Int64, T}, Dict{Int64, T}}} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Helper function that handles major chunk of code that one<em>way</em>compatible and merge_tree share</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L462-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.count_cluster_occurences-Tuple{Vector{BitVector}}" href="#MCPhyloTree.count_cluster_occurences-Tuple{Vector{BitVector}}"><code>MCPhyloTree.count_cluster_occurences</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_cluster_occurences(bit_vectors::BitVector)
    ::PriorityQueue{BitVector, Int64}</code></pre><p>–- INTERNAL –- Helper function for greedy<em>consensus</em>tree that counts the occurrences of each bit vector representing a cluster. Returns a priority queue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L211-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.depth_dicts-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode" href="#MCPhyloTree.depth_dicts-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode"><code>MCPhyloTree.depth_dicts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">depth_dicts(leaves::Vector{T})
    ::Tuple{Dict{T, Tuple{T, Dict{Int64, T}}}, Dict{T, Tuple{T, Dict{Int64, T}}}} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Helper function for one<em>way</em>compatible and merge_trees!. Creates a dictionary based on a vector of leaf nodes, and stores the depth of each node, as well as the left and right path leading to it. Based on section 6.1 of the paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L711-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.find_common_clusters-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GeneralNode" href="#MCPhyloTree.find_common_clusters-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GeneralNode"><code>MCPhyloTree.find_common_clusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_common_clusters(ref_tree, tree:T)
    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}</code></pre><p>–- INTERNAL –- Use Day&#39;s algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees.</p><p>Returns dictionary.</p><ul><li><p><code>ref_tree</code> : Tree used to create dictionary.</p></li><li><p><code>tree</code> : Tree used to create dictionary.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L283-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.get_cluster_start_indeces-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:GeneralNode" href="#MCPhyloTree.get_cluster_start_indeces-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:GeneralNode"><code>MCPhyloTree.get_cluster_start_indeces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cluster_start_indeces(ref_nodes::T, tree::T)
    ::Dict{T, Int64} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Helper function to obtain the cluster start indeces for a tree (tree), based on the nodes of another tree (ref_nodes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L529-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.get_leaf_ranks-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode" href="#MCPhyloTree.get_leaf_ranks-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode"><code>MCPhyloTree.get_leaf_ranks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function get_leaf_ranks(nodes::Vector{T})
    ::Dict{String, Int64} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Enumerate the leaf nodes in a tree. Returns a dictionary of this mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L562-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.greedy_consensus_tree-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode" href="#MCPhyloTree.greedy_consensus_tree-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode"><code>MCPhyloTree.greedy_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greedy_consensus_tree(trees::Vector{T})::T where T&lt;:GeneralNode</code></pre><p>Construct the greedy consensus tree from a set of trees that share the same leafset.  Returns the root node of the greedy consensus tree, from which it can be traversed. This algorithm is based on section 5 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L120-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.loose_consensus_tree-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode" href="#MCPhyloTree.loose_consensus_tree-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:GeneralNode"><code>MCPhyloTree.loose_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loose_consensus_tree(trees::Vector{T})::T where T&lt;:GeneralNode</code></pre><p>Construct the loose consensus tree from a set of trees that share the same leafset. I.e. a tree with all the clusters that appear in at least one tree and are compatible with all trees. Returns the root node of the loose consensus tree, from which it can be traversed. This algorithm is based on section 4 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.majority_consensus_tree-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Float64}} where T&lt;:GeneralNode" href="#MCPhyloTree.majority_consensus_tree-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Float64}} where T&lt;:GeneralNode"><code>MCPhyloTree.majority_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)
    ::T where T&lt;:GeneralNode</code></pre><p>Construct the majority rule consensus tree from a set of trees that share the same leafset. By default the output tree includes clusters that occur in over 50% of the trees. This can be customized when calling the function. The function returns the root node of the majority consensus tree, from which it can be traversed. The algorithm is based on section 3 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L14-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String, Int64}, T}} where T&lt;:GeneralNode" href="#MCPhyloTree.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String, Int64}, T}} where T&lt;:GeneralNode"><code>MCPhyloTree.max_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Recursive helper function to find the highest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L635-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.merge_trees!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GeneralNode" href="#MCPhyloTree.merge_trees!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GeneralNode"><code>MCPhyloTree.merge_trees!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_trees!(ref_tree::T, tree::T)::Vector{T}} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Merge two compatible trees, i.e. inserts all cluster of the first tree, which aren&#39;t already in the second tree, into the second tree</p><p>Returns a Tuple containing the root node of the merged tree, as well as a vector of nodes that were added.</p><ul><li><p><code>ref_tree</code> : tree used to determine common clusters.</p></li><li><p><code>tree</code> : tree used to determine common clusters.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L405-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String, Int64}, T}} where T&lt;:GeneralNode" href="#MCPhyloTree.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String, Int64}, T}} where T&lt;:GeneralNode"><code>MCPhyloTree.min_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T&lt;:GeneralNode</code></pre><p>–– INTERNAL –- Recursive helper function to find the lowest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L609-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.one_way_compatible-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GeneralNode" href="#MCPhyloTree.one_way_compatible-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GeneralNode"><code>MCPhyloTree.one_way_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one_way_compatible(ref_tree::T, tree::T)::T where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Takes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.</p><p>Returns root node of edited tree.</p><ul><li><p><code>ref_tree</code> : tree used to determine clusters.</p></li><li><p><code>tree</code> : tree used to determine clusters.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L369-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.order_tree!-Union{Tuple{T}, Tuple{T, Dict{T, Int64}}, Tuple{T, Dict{T, Int64}, Any}} where T&lt;:GeneralNode" href="#MCPhyloTree.order_tree!-Union{Tuple{T}, Tuple{T, Dict{T, Int64}}, Tuple{T, Dict{T, Int64}, Any}} where T&lt;:GeneralNode"><code>MCPhyloTree.order_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())
    ::Vector{T} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Helper function to order a tree based on cluster indeces and return the leaves of the ordered tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L584-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.set_node_stats!-Union{Tuple{T}, Tuple{T, Vector{T}, Bool}, Tuple{T, Vector{T}, Bool, Float64}} where T&lt;:GeneralNode" href="#MCPhyloTree.set_node_stats!-Union{Tuple{T}, Tuple{T, Vector{T}, Bool}, Tuple{T, Vector{T}, Bool, Float64}} where T&lt;:GeneralNode"><code>MCPhyloTree.set_node_stats!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_node_stats!(tree::T, trees::Vector{T}, majority::Bool)
    ::Nothing where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Helper function for the construction of a consensus tree. Calculates the inc_lengths and statistics of the nodes in the consensus tree. If dealing with a (in-progress) majority consensus tree, this function will also delete its non-majority clusters (handled by the &#39;majority&#39; boolean).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L239-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.x_left-Tuple{T} where T&lt;:GeneralNode" href="#MCPhyloTree.x_left-Tuple{T} where T&lt;:GeneralNode"><code>MCPhyloTree.x_left</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x_left(node::T)::Tuple{T,Vector{T}} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Helper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L661-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.x_right-Tuple{T} where T&lt;:GeneralNode" href="#MCPhyloTree.x_right-Tuple{T} where T&lt;:GeneralNode"><code>MCPhyloTree.x_right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x_right(node::T)::Tuple{T,Vector{T}} where T&lt;:GeneralNode</code></pre><p>–- INTERNAL –- Helper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Consensus.jl#L686-L692">source</a></section></article><h2 id="Tree-Ladderizing"><a class="docs-heading-anchor" href="#Tree-Ladderizing">Tree Ladderizing</a><a id="Tree-Ladderizing-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Ladderizing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.ladderize_tree!-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:GeneralNode" href="#MCPhyloTree.ladderize_tree!-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:GeneralNode"><code>MCPhyloTree.ladderize_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ladderize_tree!(root::T, ascending::Bool=true)
    ::Nothing where T&lt;:GeneralNode</code></pre><p>This function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>ascending</code> : Boolean, determines whether to sort in ascending (true) or               descending (false) order.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Ladderizing.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.ladderize_tree-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:GeneralNode" href="#MCPhyloTree.ladderize_tree-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:GeneralNode"><code>MCPhyloTree.ladderize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ladderize_tree(root::T, ascending::Bool=true)::T where T&lt;:GeneralNode</code></pre><p>This function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>ascending</code> : Boolean, determines whether to sort in ascending (true) or                descending (false) order.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/8e6e0aaa71cae58aaaa33916a6646316aad777cf/src/Building/Tree_Ladderizing.jl#L28-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« Basics</a><a class="docs-footer-nextpage" href="../distance/">Distance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 20 August 2021 12:45">Friday 20 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
