<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building · MCPhyloTree.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MCPhyloTree.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><a class="tocitem" href="../basics/">Basics</a></li><li class="is-active"><a class="tocitem" href>Building</a><ul class="internal"><li><a class="tocitem" href="#Matrix-Representation"><span>Matrix Representation</span></a></li><li><a class="tocitem" href="#Newick-Parsing"><span>Newick Parsing</span></a></li><li><a class="tocitem" href="#Build-Trees-from-Matrices"><span>Build Trees from Matrices</span></a></li><li><a class="tocitem" href="#Tree-Estimation-from-Matrices"><span>Tree Estimation from Matrices</span></a></li><li><a class="tocitem" href="#Consensus-Tree-computation"><span>Consensus Tree computation</span></a></li><li><a class="tocitem" href="#Tree-Ladderizing"><span>Tree Ladderizing</span></a></li></ul></li><li><a class="tocitem" href="../distance/">Distance</a></li><li><a class="tocitem" href="../moves/">Moves</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Building</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Building</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/MCPhyloTree.jl/blob/main/docs/src/building.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tree-Building-and-Transformations"><a class="docs-heading-anchor" href="#Tree-Building-and-Transformations">Tree Building &amp; Transformations</a><a id="Tree-Building-and-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Building-and-Transformations" title="Permalink"></a></h1><p>The tree building methods listed here ensure that the nodes of the tree(s) they build are fully initialized, i.e. they have a unique number, binary representation and a height. Therefore there is no need to run <em>initialize_tree!</em> or <em>update_tree!</em> after running them.</p><h2 id="Matrix-Representation"><a class="docs-heading-anchor" href="#Matrix-Representation">Matrix Representation</a><a id="Matrix-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Representation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.leave_incidence_matrix-Tuple{G} where G&lt;:AbstractNode" href="#MCPhyloTree.leave_incidence_matrix-Tuple{G} where G&lt;:AbstractNode"><code>MCPhyloTree.leave_incidence_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function leave_incidence_matrix(root::G)::Matrix{Float64} where {G&lt;:AbstractNode}</code></pre><p>Calculate the incidence matrix of the tree whos root node is <code>root</code> For a tree with <span>$m$</span> leaves and <span>$n$</span> vertecies this function returns an <span>$m \times n$</span> matrix <span>$L$</span>, where <span>$L_{ij} = 1$</span> if vertex <span>$j$</span> is on the path from leave <span>$i$</span> to the root of the tree and <span>$0$</span> otherwise.</p><p>Returns leave incidence matrix.</p><ul><li><code>root</code> : Root node of the tree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree2Matrix.jl#L100-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.to_covariance-Union{Tuple{T}, Tuple{N}, Tuple{N, Vector{T}}} where {N&lt;:AbstractNode, T&lt;:Real}" href="#MCPhyloTree.to_covariance-Union{Tuple{T}, Tuple{N}, Tuple{N, Vector{T}}} where {N&lt;:AbstractNode, T&lt;:Real}"><code>MCPhyloTree.to_covariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N&lt;:AbstractNode,T&lt;: Real}</code></pre><p>Calcualte the variance-covariance matrix from <code>tree</code>. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.</p><p>Returns an Array of Real numbers.</p><ul><li><p><code>tree</code> : Node in tree of interest.</p></li><li><p><code>blv</code> : branchlength vector of tree.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree2Matrix.jl#L64-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.to_df-Tuple{GeneralNode}" href="#MCPhyloTree.to_df-Tuple{GeneralNode}"><code>MCPhyloTree.to_df</code></a> — <span class="docstring-category">Method</span></header><section><div><p>to_df(root::GeneralNode)::Tuple{Array{Float64}, Vector{String}}</p><p>This function returns a matrix representation of the tree structure and a vector with the column names. The entry <code>mat[i,j]</code> is the length of the edge connecting node <code>i</code> with node <code>j</code>. Returns Tuple containing the matrix and a vector of names.</p><ul><li><code>root</code> : root of tree used to create matrix represenation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree2Matrix.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.to_distance_matrix-Tuple{T} where T&lt;:AbstractNode" href="#MCPhyloTree.to_distance_matrix-Tuple{T} where T&lt;:AbstractNode"><code>MCPhyloTree.to_distance_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_distance_matrix(tree::T)::Array{Float64,2} where T &lt;:AbstractNode</code></pre><p>Calculate the distance matrix over the set of leaves.</p><p>Returns an Array of Floats.</p><ul><li><code>tree</code> : root node of tree used to perform caclulcation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree2Matrix.jl#L41-L49">source</a></section></article><h2 id="Newick-Parsing"><a class="docs-heading-anchor" href="#Newick-Parsing">Newick Parsing</a><a id="Newick-Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Newick-Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.ParseNewick-Tuple{String}" href="#MCPhyloTree.ParseNewick-Tuple{String}"><code>MCPhyloTree.ParseNewick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParseNewick(s::String)::Union{GeneralNode, Array{GeneralNode, 1}}</code></pre><p>This function takes a string - either a filename or a newick string - and reads the file / string to return an array of trees (represented as Node objects). The file should solely  consist of newick tree representations, separated by line. The function checks for proper  newick formatting, and will return an error if the string / file is incorrectly formatted.</p><p>Newick string input: Returns the root of the tree represented by the newick string. Filename input: Returns an Array of Nodes; each Node is the root of the tree represented by a newick string in the file.</p><ul><li><code>s</code> : newick string or name of file containing newick strings to parse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/ParseNewick.jl#L132-L145">source</a></section></article><h2 id="Build-Trees-from-Matrices"><a class="docs-heading-anchor" href="#Build-Trees-from-Matrices">Build Trees from Matrices</a><a id="Build-Trees-from-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Trees-from-Matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.from_df" href="#MCPhyloTree.from_df"><code>MCPhyloTree.from_df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function from_df(df::Array{T,2}, name_list::Vector{String})::GeneralNode{T, Int64} where T&lt;:Real</code></pre><p>This function takes an adjacency matrix and a vector of names and turns it into a tree. No checks are performed.</p><p>Returns the root node of the tree.</p><ul><li><code>df</code> : matrix with edge weights</li><li><code>name_list</code> : a list of names such that they match the column indices of the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Building.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.create_tree_from_leaves" href="#MCPhyloTree.create_tree_from_leaves"><code>MCPhyloTree.create_tree_from_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function create_tree_from_leaves(leaf_nodes::Vector{String}, rooted::Bool=false&lt;:AbstractNode</code></pre><p>Build a random tree from a list of leaf names. The tree is unrooted by default.</p><p>Returns the root node of the new tree.</p><ul><li><p><code>leaf_nodes</code> : A list of strings which are used as the names of the leaves.</p></li><li><p><code>rooted</code> : Boolean indicating if the tree should be rooted</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Building.jl#L37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.cov2tree" href="#MCPhyloTree.cov2tree"><code>MCPhyloTree.cov2tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function cov2tree(covmat::Array{&lt;:T, 2}, names::Vector{&lt;:AbstractString}, numbers::Vector{Int64}; tol::Real=1e-7)::GeneralNode{T, Int64} where T&lt;:Real</code></pre><p>This function reconstructs a tree from a covariance matrix. It takes a covariance matrix,  a vector of leaf names and a vector of node numbers as mandatory arguments. The order of the two vectors must correspond to the order of rows and columns in the covariance matrix. Optionally, the <code>tol</code> paramter indicates  the boundary below which all values are treated as zero.</p><p>Returns the root node of the tree corresponding to the supplied covariance matrix.</p><ul><li><code>covmat</code> : covariance matrix</li><li><code>names</code> : a list of names such that they match the column/row indices of the matrix</li><li><code>numbers</code> : a list of Integers such that they match the column/row indices of the matrix</li><li><code>tol</code> : cut off value below which all values are treated as zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Building.jl#L153-L167">source</a></section></article><h2 id="Tree-Estimation-from-Matrices"><a class="docs-heading-anchor" href="#Tree-Estimation-from-Matrices">Tree Estimation from Matrices</a><a id="Tree-Estimation-from-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Estimation-from-Matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.neighbor_joining" href="#MCPhyloTree.neighbor_joining"><code>MCPhyloTree.neighbor_joining</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighbor_joining(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><p><code>dm</code> : Matrix used to create Tree.</p></li><li><p><code>leaf_names</code> : Array containing names of leaf nodes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Clustering.jl#L124-L135">source</a></section><section><div><pre><code class="nohighlight hljs">neighbor_joining(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><code>dm</code> : Matrix from which to create tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Clustering.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.upgma" href="#MCPhyloTree.upgma"><code>MCPhyloTree.upgma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">upgma(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><p><code>dm</code> : Matrix from which to create the tree.</p></li><li><p><code>leaf_names</code> : array of strings containing names of leaf nodes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Clustering.jl#L1-L12">source</a></section><section><div><pre><code class="nohighlight hljs">upgma(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves.</p><p>Returns a node of the resulting tree, from which it can be traversed.</p><ul><li><code>dm</code> : Matrix from which to create the tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Clustering.jl#L27-L36">source</a></section></article><h2 id="Consensus-Tree-computation"><a class="docs-heading-anchor" href="#Consensus-Tree-computation">Consensus Tree computation</a><a id="Consensus-Tree-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Consensus-Tree-computation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.majority_consensus_tree" href="#MCPhyloTree.majority_consensus_tree"><code>MCPhyloTree.majority_consensus_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)
    ::T where T&lt;:AbstractNode</code></pre><p>Construct the majority rule consensus tree from a set of trees that share the same leafset. By default the output tree includes clusters that occur in over 50% of the trees. This can be customized when calling the function. The function returns the root node of the majority consensus tree, from which it can be traversed. The algorithm is based on section 3 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Consensus.jl#L14-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.loose_consensus_tree" href="#MCPhyloTree.loose_consensus_tree"><code>MCPhyloTree.loose_consensus_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loose_consensus_tree(trees::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>Construct the loose consensus tree from a set of trees that share the same leafset. I.e. a tree with all the clusters that appear in at least one tree and are compatible with all trees. Returns the root node of the loose consensus tree, from which it can be traversed. This algorithm is based on section 4 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Consensus.jl#L77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.greedy_consensus_tree" href="#MCPhyloTree.greedy_consensus_tree"><code>MCPhyloTree.greedy_consensus_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">greedy_consensus_tree(trees::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>Construct the greedy consensus tree from a set of trees that share the same leafset.  Returns the root node of the greedy consensus tree, from which it can be traversed. This algorithm is based on section 5 and 6.1 of:</p><p>Jesper Jansson, Chuanqi Shen, and Wing-Kin Sung. 2016. Improved algorithms for constructing consensustrees. J. ACM 63, 3, Article 28 (June 2016), 24 pages https://dl.acm.org/doi/pdf/10.1145/2925985</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Consensus.jl#L119-L130">source</a></section></article><h2 id="Tree-Ladderizing"><a class="docs-heading-anchor" href="#Tree-Ladderizing">Tree Ladderizing</a><a id="Tree-Ladderizing-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Ladderizing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.ladderize_tree!-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:AbstractNode" href="#MCPhyloTree.ladderize_tree!-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:AbstractNode"><code>MCPhyloTree.ladderize_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ladderize_tree!(root::T, ascending::Bool=true) where T&lt;:AbstractNode</code></pre><p>This function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>ascending</code> : Boolean, determines whether to sort in ascending (true) or               descending (false) order.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Ladderizing.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCPhyloTree.ladderize_tree-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:AbstractNode" href="#MCPhyloTree.ladderize_tree-Union{Tuple{T}, Tuple{T, Bool}} where T&lt;:AbstractNode"><code>MCPhyloTree.ladderize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ladderize_tree(root::T, ascending::Bool=true)::T where T&lt;:AbstractNode</code></pre><p>This function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants.</p><ul><li><p><code>root</code> : root Node of tree.</p></li><li><p><code>ascending</code> : Boolean, determines whether to sort in ascending (true) or                descending (false) order.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/MCPhyloTree.jl/blob/2f11badae4fd1409f07fc67ee96e85597f5f4845/src/Building/Tree_Ladderizing.jl#L28-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« Basics</a><a class="docs-footer-nextpage" href="../distance/">Distance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 30 January 2023 10:58">Monday 30 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
